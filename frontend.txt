// File: frontend/package.json
{
  "name": "bibletok-frontend",
  "private": true,
  "version": "0.1.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "@tailwindcss/postcss": "^4.0.3",
    "@tailwindcss/vite": "^4.0.3",
    "lucide-react": "^0.474.0",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "tailwindcss": "^4.0.3"
  },
  "devDependencies": {
    "@eslint/js": "^9.17.0",
    "@types/react": "^18.3.18",
    "@types/react-dom": "^18.3.5",
    "@vitejs/plugin-react": "^4.3.4",
    "eslint": "^9.17.0",
    "eslint-plugin-react-hooks": "^5.0.0",
    "eslint-plugin-react-refresh": "^0.4.16",
    "globals": "^15.14.0",
    "typescript": "~5.6.2",
    "typescript-eslint": "^8.18.2",
    "vite": "^6.0.5"
  }
}

// File: frontend/index.html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/bible-icon.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
    <meta name="theme-color" content="#000000" />
    <title>BibleTok</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>

// File: frontend/tsconfig.json
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["src"],
  "references": [{ "path": "./tsconfig.node.json" }]
}

// File: frontend/tsconfig.node.json
{
  "compilerOptions": {
    "composite": true,
    "skipLibCheck": true,
    "module": "ESNext",
    "moduleResolution": "bundler",
    "allowSyntheticDefaultImports": true
  },
  "include": ["vite.config.ts"]
}

// File: frontend/vite.config.ts
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import tailwindcss from "@tailwindcss/vite";

export default defineConfig({
  plugins: [react(), tailwindcss()],
  server: {
    proxy: {
      '/api': {
        target: 'http://localhost:3000',
        changeOrigin: true,
        secure: false
      }
    }
  }
});

// File: frontend/src/index.css
@import "tailwindcss";

html, body {
  overscroll-behavior-y: contain;
  overflow: hidden;
  touch-action: manipulation;
}

body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  background-color: #000;
  color: #fff;
}

.hide-scroll::-webkit-scrollbar {
  display: none;
}
.hide-scroll {
  -ms-overflow-style: none;
  scrollbar-width: none;
}

@keyframes slide-up {
  0% { transform: translateY(0); opacity: 1; }
  100% { transform: translateY(-100%); opacity: 0; }
}

@keyframes slide-down {
  0% { transform: translateY(0); opacity: 1; }
  100% { transform: translateY(100%); opacity: 0; }
}

.animate-slide-up {
  animation: slide-up 0.2s ease-out forwards;
}

.animate-slide-down {
  animation: slide-down 0.2s ease-out forwards;
}

// File: frontend/src/main.tsx
import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App.tsx'
import './index.css'
import { BibleContextProvider } from './contexts/BibleContext'

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <BibleContextProvider>
      <App />
    </BibleContextProvider>
  </React.StrictMode>,
)

// File: frontend/src/vite-env.d.ts
/// <reference types="vite/client" />

// File: frontend/src/types/Bible.ts
export interface Bible {
  id: string;
  name: string;
  abbreviation: string;
  description: string;
  language: {
    id: string;
    name: string;
    nameLocal: string;
    script: string;
    scriptDirection: string;
  };
}

export interface BibleVerse {
  id: string;
  reference: string;
  text: string;
  copyright: string;
}

export interface VerseWithBackground extends BibleVerse {
  backgroundGradient: string;
}

// File: frontend/src/contexts/BibleContext.tsx
import React, { createContext, useContext, useState, useEffect, useCallback, ReactNode } from 'react';
import { Bible, VerseWithBackground } from '../types/Bible';

// Background gradients to cycle through
const backgroundGradients = [
  "from-blue-900 to-indigo-800",
  "from-green-900 to-teal-800", 
  "from-purple-900 to-pink-800",
  "from-red-900 to-orange-800",
  "from-emerald-900 to-cyan-800",
  "from-amber-900 to-yellow-700",
  "from-violet-900 to-fuchsia-800"
];

interface BibleContextProps {
  loading: boolean;
  availableBibles: Bible[];
  currentBible: Bible | null;
  currentVerses: VerseWithBackground[];
  currentIndex: number;
  setCurrentIndex: (index: number) => void;
  fetchNextVerses: () => Promise<void>;
  fetchPreviousVerses: () => Promise<void>;
  setCurrentBible: (bibleId: string) => void;
  likes: Record<string, boolean>;
  toggleLike: (verseId: string) => void;
}

const BibleContext = createContext<BibleContextProps | undefined>(undefined);

export const BibleContextProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  const [loading, setLoading] = useState(true);
  const [availableBibles, setAvailableBibles] = useState<Bible[]>([]);
  const [currentBible, setCurrentBible] = useState<Bible | null>(null);
  const [currentVerses, setCurrentVerses] = useState<VerseWithBackground[]>([]);
  const [currentIndex, setCurrentIndex] = useState(0);
  const [likes, setLikes] = useState<Record<string, boolean>>({});

  // Initialize by loading bibles and likes from local storage
  useEffect(() => {
    const fetchBibles = async () => {
      try {
        const response = await fetch('/api/bibles');
        const data = await response.json();
        
        if (data.bibles && data.bibles.length > 0) {
          setAvailableBibles(data.bibles);
          
          // Get saved bible or use the first one
          const savedBibleId = localStorage.getItem('currentBible');
          const initialBible = savedBibleId 
            ? data.bibles.find((bible: Bible) => bible.id === savedBibleId) 
            : data.bibles[0];
            
          if (initialBible) {
            setCurrentBible(initialBible);
          }
        }
      } catch (error) {
        console.error('Error fetching bibles:', error);
      }
    };
    
    // Load likes from localStorage
    const savedLikes = localStorage.getItem('bibletok-likes');
    if (savedLikes) {
      setLikes(JSON.parse(savedLikes));
    }
    
    fetchBibles();
  }, []);

  // Save likes to localStorage when changed
  useEffect(() => {
    localStorage.setItem('bibletok-likes', JSON.stringify(likes));
  }, [likes]);

  // When current bible changes, save to localStorage and load verses
  useEffect(() => {
    if (currentBible) {
      localStorage.setItem('currentBible', currentBible.id);
      fetchInitialVerses();
    }
  }, [currentBible]);

  const fetchInitialVerses = async () => {
    if (!currentBible) return;
    
    setLoading(true);
    try {
      const response = await fetch(`/api/verses/${currentBible.id}`);
      const data = await response.json();
      
      if (data.verses) {
        // Add background gradients to verses
        const versesWithBackgrounds = data.verses.map((verse: any, index: number) => ({
          ...verse,
          backgroundGradient: backgroundGradients[index % backgroundGradients.length]
        }));
        
        setCurrentVerses(versesWithBackgrounds);
        setCurrentIndex(0);
      }
    } catch (error) {
      console.error('Error fetching verses:', error);
    } finally {
      setLoading(false);
    }
  };

  const fetchNextVerses = async () => {
    if (!currentBible || currentVerses.length === 0) return;
    
    // If we're not close to the end of our current collection, no need to fetch more
    if (currentIndex < currentVerses.length - 3) return;
    
    setLoading(true);
    try {
      const lastVerseId = currentVerses[currentVerses.length - 1].id;
      const response = await fetch(`/api/verses/${currentBible.id}/after/${lastVerseId}`);
      const data = await response.json();
      
      if (data.verses && data.verses.length > 0) {
        // Add background gradients to new verses
        const newVersesWithBackgrounds = data.verses.map((verse: any, index: number) => ({
          ...verse,
          backgroundGradient: backgroundGradients[(currentVerses.length + index) % backgroundGradients.length]
        }));
        
        setCurrentVerses(prevVerses => [...prevVerses, ...newVersesWithBackgrounds]);
      }
    } catch (error) {
      console.error('Error fetching next verses:', error);
    } finally {
      setLoading(false);
    }
  };

  const fetchPreviousVerses = async () => {
    if (!currentBible || currentVerses.length === 0 || currentIndex > 2) return;
    
    setLoading(true);
    try {
      const firstVerseId = currentVerses[0].id;
      const response = await fetch(`/api/verses/${currentBible.id}/before/${firstVerseId}`);
      const data = await response.json();
      
      if (data.verses && data.verses.length > 0) {
        // Add background gradients to new verses
        const newVersesWithBackgrounds = data.verses.map((verse: any, index: number) => ({
          ...verse,
          backgroundGradient: backgroundGradients[index % backgroundGradients.length]
        }));
        
        setCurrentVerses(prevVerses => [...newVersesWithBackgrounds, ...prevVerses]);
        // Adjust currentIndex since we've prepended verses
        setCurrentIndex(prev => prev + data.verses.length);
      }
    } catch (error) {
      console.error('Error fetching previous verses:', error);
    } finally {
      setLoading(false);
    }
  };

  const changeBible = useCallback((bibleId: string) => {
    const bible = availableBibles.find(b => b.id === bibleId);
    if (bible) {
      setCurrentBible(bible);
    }
  }, [availableBibles]);

  const toggleLike = (verseId: string) => {
    setLikes(prev => ({
      ...prev,
      [verseId]: !prev[verseId]
    }));
  };

  return (
    <BibleContext.Provider value={{
      loading,
      availableBibles,
      currentBible,
      currentVerses,
      currentIndex,
      setCurrentIndex,
      fetchNextVerses,
      fetchPreviousVerses,
      setCurrentBible: changeBible,
      likes,
      toggleLike
    }}>
      {children}
    </BibleContext.Provider>
  );
};

export const useBible = () => {
  const context = useContext(BibleContext);
  if (context === undefined) {
    throw new Error('useBible must be used within a BibleContextProvider');
  }
  return context;
};

// File: frontend/src/components/VerseCard.tsx
import React, { useState } from 'react';
import { Heart, Share, ExternalLink } from 'lucide-react';
import { VerseWithBackground } from '../types/Bible';
import { useBible } from '../contexts/BibleContext';

interface VerseCardProps {
  verse: VerseWithBackground;
  onSwipeUp: () => void;
  onSwipeDown: () => void;
}

export const VerseCard: React.FC<VerseCardProps> = ({ verse, onSwipeUp, onSwipeDown }) => {
  const [touchStart, setTouchStart] = useState(0);
  const [touchEnd, setTouchEnd] = useState(0);
  const [swipeTransition, setSwipeTransition] = useState(false);
  const [swipeDirection, setSwipeDirection] = useState<'up' | 'down' | null>(null);
  const { likes, toggleLike } = useBible();

  const isLiked = likes[verse.id] || false;

  const handleTouchStart = (e: React.TouchEvent) => {
    setTouchStart(e.targetTouches[0].clientY);
  };
  
  const handleTouchMove = (e: React.TouchEvent) => {
    setTouchEnd(e.targetTouches[0].clientY);
  };
  
  const handleTouchEnd = () => {
    if (touchStart - touchEnd > 100) {
      handleSwipeUp();
    } else if (touchEnd - touchStart > 100) {
      handleSwipeDown();
    }
  };

  const handleSwipeUp = () => {
    setSwipeDirection('up');
    setSwipeTransition(true);
    setTimeout(() => {
      onSwipeUp();
      setTimeout(() => {
        setSwipeTransition(false);
      }, 50);
    }, 200);
  };

  const handleSwipeDown = () => {
    setSwipeDirection('down');
    setSwipeTransition(true);
    setTimeout(() => {
      onSwipeDown();
      setTimeout(() => {
        setSwipeTransition(false);
      }, 50);
    }, 200);
  };

  const handleShare = async () => {
    try {
      if (navigator.share) {
        await navigator.share({
          title: verse.reference,
          text: verse.text,
          url: window.location.href
        });
      } else {
        const text = `${verse.reference}\n${verse.text}`;
        await navigator.clipboard.writeText(text);
        alert('Verse copied to clipboard!');
      }
    } catch (error) {
      console.error('Error sharing:', error);
    }
  };

  const handleDoubleTap = () => {
    toggleLike(verse.id);
  };

  return (
    <div 
      className={`h-full w-full flex items-center justify-center bg-gradient-to-b ${verse.backgroundGradient} ${
        swipeTransition 
        ? swipeDirection === 'up' 
          ? 'animate-slide-up' 
          : 'animate-slide-down'
        : ''
      }`}
      onTouchStart={handleTouchStart}
      onTouchMove={handleTouchMove}
      onTouchEnd={handleTouchEnd}
      onDoubleClick={handleDoubleTap}
    >
      <div className="w-full max-w-md text-center px-6">
        <div className="mb-8">
          <h1 className="text-2xl font-bold mb-6 text-white">{verse.text}</h1>
          <p className="text-lg text-white/90 mb-2">{verse.reference}</p>
        </div>
        
        {/* Action buttons */}
        <div className="fixed bottom-8 right-4 flex flex-col items-center space-y-4">
          <button 
            className="flex flex-col items-center"
            onClick={() => toggleLike(verse.id)}
          >
            <Heart className={`h-8 w-8 ${isLiked ? 'fill-red-500 text-red-500' : 'text-white'}`} />
            <span className="text-xs mt-1 text-white">Like</span>
          </button>
          
          <button className="flex flex-col items-center" onClick={handleShare}>
            <Share className="h-8 w-8 text-white" />
            <span className="text-xs mt-1 text-white">Share</span>
          </button>
          
          <a 
            href={`https://www.biblegateway.com/passage/?search=${encodeURIComponent(verse.reference)}`} 
            target="_blank" 
            rel="noopener noreferrer"
            className="flex flex-col items-center"
          >
            <ExternalLink className="h-8 w-8 text-white" />
            <span className="text-xs mt-1 text-white">Read</span>
          </a>
        </div>
      </div>
    </div>
  );
};

// File: frontend/src/components/VersionSelector.tsx
import React, { useState } from 'react';
import { Book, X } from 'lucide-react';
import { useBible } from '../contexts/BibleContext';

export const VersionSelector: React.FC = () => {
  const [isModalOpen, setIsModalOpen] = useState(false);
  const { availableBibles, currentBible, setCurrentBible } = useBible();

  const toggleModal = () => {
    setIsModalOpen(!isModalOpen);
  };

  const handleVersionSelect = (bibleId: string) => {
    setCurrentBible(bibleId);
    setIsModalOpen(false);
  };

  return (
    <>
      <button 
        onClick={toggleModal}
        className="p-2 rounded-full hover:bg-white/10"
        aria-label="Select Bible version"
      >
        <Book className="h-6 w-6 text-white" />
      </button>

      {isModalOpen && (
        <div className="fixed inset-0 z-50 bg-black/80 backdrop-blur-sm flex items-center justify-center">
          <div className="bg-gray-900 rounded-lg p-6 w-80 max-w-full">
            <div className="flex justify-between items-center mb-4">
              <h2 className="text-xl font-bold text-white">Bible Versions</h2>
              <button 
                onClick={toggleModal}
                className="text-white/70 hover:text-white"
              >
                <X className="h-6 w-6" />
              </button>
            </div>
            <div className="space-y-2 max-h-[60vh] overflow-y-auto">
              {availableBibles.map((bible) => (
                <button
                  key={bible.id}
                  onClick={() => handleVersionSelect(bible.id)}
                  className={`w-full p-3 text-left rounded-lg ${
                    currentBible?.id === bible.id 
                      ? 'bg-blue-600 text-white' 
                      : 'bg-gray-800 text-white hover:bg-gray-700'
                  }`}
                >
                  <span className="font-semibold">{bible.abbreviation}</span>
                  <p className="text-sm opacity-80">{bible.name}</p>
                  {bible.language.nameLocal !== bible.language.name && (
                    <p className="text-xs opacity-60 mt-1">{bible.language.nameLocal}</p>
                  )}
                </button>
              ))}
            </div>
          </div>
        </div>
      )}
    </>
  );
};

// File: frontend/src/components/Navigation.tsx
import React from 'react';
import { ChevronUp, ChevronDown } from 'lucide-react';

interface NavigationProps {
  onPrevious: () => void;
  onNext: () => void;
  canGoUp: boolean;
  canGoDown: boolean;
}

export const Navigation: React.FC<NavigationProps> = ({ 
  onPrevious, 
  onNext,
  canGoUp,
  canGoDown
}) => {
  return (
    <div className="absolute top-1/2 right-4 transform -translate-y-1/2 flex flex-col space-y-4">
      <button 
        onClick={onPrevious} 
        disabled={!canGoUp}
        className={`p-2 rounded-full bg-white/20 ${!canGoUp ? 'opacity-50' : 'hover:bg-white/30'}`}
        aria-label="Previous verse"
      >
        <ChevronUp className="h-6 w-6 text-white" />
      </button>
      <button 
        onClick={onNext} 
        disabled={!canGoDown}
        className={`p-2 rounded-full bg-white/20 ${!canGoDown ? 'opacity-50' : 'hover:bg-white/30'}`}
        aria-label="Next verse"
      >
        <ChevronDown className="h-6 w-6 text-white" />
      </button>
    </div>
  );
};

// File: frontend/src/components/Header.tsx
import React from 'react';
import { VersionSelector } from './VersionSelector';

export const Header: React.FC = () => {
  return (
    <div className="absolute top-0 left-0 right-0 z-10 p-4 flex justify-between items-center">
      <div className="text-xl font-bold text-white">BibleTok</div>
      <VersionSelector />
    </div>
  );
};

// File: frontend/src/components/LoadingIndicator.tsx
import React from 'react';
import { Loader2 } from 'lucide-react';

export const LoadingIndicator: React.FC = () => {
  return (
    <div className="flex flex-col items-center justify-center h-screen w-full">
      <Loader2 className="h-10 w-10 text-white animate-spin mb-4" />
      <p className="text-white">Loading verses...</p>
    </div>
  );
};

// File: frontend/src/components/ProgressIndicator.tsx
import React from 'react';

interface ProgressIndicatorProps {
  currentIndex: number;
  totalItems: number;
}

export const ProgressIndicator: React.FC<ProgressIndicatorProps> = ({ 
  currentIndex, 
  totalItems 
}) => {
  const percentage = totalItems > 0 ? ((currentIndex + 1) / totalItems) * 100 : 0;
  
  return (
    <div className="absolute bottom-0 left-0 right-0 h-1 bg-black/20">
      <div 
        className="h-full bg-white"
        style={{ width: `${percentage}%` }}
      />
    </div>
  );
};

// File: frontend/src/App.tsx
import React, { useEffect } from 'react';
import { VerseCard } from './components/VerseCard';
import { Navigation } from './components/Navigation';
import { Header } from './components/Header';
import { LoadingIndicator } from './components/LoadingIndicator';
import { ProgressIndicator } from './components/ProgressIndicator';
import { useBible } from './contexts/BibleContext';

const App: React.FC = () => {
  const { 
    loading, 
    currentVerses, 
    currentIndex, 
    setCurrentIndex,
    fetchNextVerses,
    fetchPreviousVerses
  } = useBible();

  useEffect(() => {
    // Preload the next set of verses when we're getting close to the end
    if (currentIndex >= currentVerses.length - 3) {
      fetchNextVerses();
    }
  }, [currentIndex, currentVerses.length, fetchNextVerses]);

  const handleSwipeUp = () => {
    if (currentIndex < currentVerses.length - 1) {
      setCurrentIndex(currentIndex + 1);
    }
  };

  const handleSwipeDown = () => {
    if (currentIndex > 0) {
      setCurrentIndex(currentIndex - 1);
    }
  };

  if (loading && currentVerses.length === 0) {
    return <LoadingIndicator />;
  }

  return (
    <div className="h-screen w-full overflow-hidden bg-black relative">
      <Header />
      
      {currentVerses.length > 0 && (
        <div className="h-full w-full">
          <VerseCard 
            verse={currentVerses[currentIndex]} 
            onSwipeUp={handleSwipeUp}
            onSwipeDown={handleSwipeDown}
          />
          
          <Navigation 
            onPrevious={handleSwipeDown}
            onNext={handleSwipeUp}
            canGoUp={currentIndex > 0}
            canGoDown={currentIndex < currentVerses.length - 1}
          />
          
          <ProgressIndicator 
            currentIndex={currentIndex} 
            totalItems={currentVerses.length} 
          />
        </div>
      )}
    </div>
  );
};

export default App;